#!/bin/bash

set -e # Exit immediately if a command exits with a non-zero status.

# --- Default values ---
default_base_remote="origin"
default_head_remote="origin"
# Base branch will be auto-detected if not specified

# --- Argument Parsing ---
# Using getopt for robust parsing. ':' means the option requires an argument.
options=$(getopt -o '' --long base-remote:,base-branch:,head-remote:,help -n "$0" -- "$@")
if [ $? != 0 ]; then
  echo "Argument parsing failed. Use --help for usage." >&2
  exit 1
fi

# Note the quotes around "$options": they are essential!
eval set -- "$options"

base_remote="$default_base_remote"
base_branch="" # Will be auto-detected later if empty
head_remote="$default_head_remote"

while true; do
  case "$1" in
  --base-remote)
    base_remote="$2"
    shift 2
    ;;
  --base-branch)
    base_branch="$2"
    shift 2
    ;;
  --head-remote)
    head_remote="$2"
    shift 2
    ;;
  --help)
    echo "Usage: $0 [--base-remote <remote>] [--base-branch <branch>] [--head-remote <remote>]"
    echo "  --base-remote  Remote containing the target branch (default: $default_base_remote)."
    echo "  --base-branch  Target branch name (default: auto-detect from base-remote)."
    echo "  --head-remote  Remote to push the source branch to (default: value of --base-remote, or '$default_head_remote' if --base-remote is not set)."
    exit 0
    ;;
  --)
    shift
    break
    ;;
  *) break ;;
  esac
done

# If head_remote wasn't explicitly set, make it the same as base_remote
if [ "$head_remote" = "$default_head_remote" ] && [ "$base_remote" != "$default_base_remote" ]; then
  head_remote="$base_remote"
fi

echo "Base Remote: $base_remote"
echo "Head Remote: $head_remote"

# --- Get current branch (head branch) ---
head_branch=$(git rev-parse --abbrev-ref HEAD)
if [ -z "$head_branch" ] || [ "$head_branch" = "HEAD" ]; then
  echo "Error: Could not determine the current branch name." >&2
  exit 1
fi
echo "Head Branch (Current): $head_branch"

# --- Check for uncommitted changes ---
# Warn but don't exit, as gh pr create might still work depending on the changes
if ! git diff --quiet --exit-code; then
  echo "Warning: You have uncommitted changes." >&2
fi
# Also check staged changes
if ! git diff --cached --quiet --exit-code; then
  echo "Warning: You have staged changes." >&2
fi

# --- Fetch base remote ---
echo "Fetching base remote '$base_remote'..."
git fetch "$base_remote"

# --- Determine Base Branch and Ref ---
if [ -z "$base_branch" ]; then
  # Auto-detect base branch from the base remote's HEAD
  base_ref=$(git symbolic-ref "refs/remotes/$base_remote/HEAD")
  if [ -z "$base_ref" ]; then
    echo "Error: Could not automatically determine the default branch for remote '$base_remote'." >&2
    echo "Please specify the target branch using --base-branch." >&2
    exit 1
  fi
  # Extract the short branch name from the full ref (e.g., refs/remotes/origin/main -> main)
  base_branch=$(basename "$base_ref")
  echo "Auto-detected base branch: $base_branch"
else
  # User specified base branch, construct the ref
  base_ref="refs/remotes/$base_remote/$base_branch"
  # Verify the branch exists on the remote
  if ! git show-ref --verify --quiet "$base_ref"; then
    echo "Error: Branch '$base_branch' not found on remote '$base_remote'." >&2
    echo "Please ensure the branch exists and the remote is fetched." >&2
    exit 1
  fi
  echo "Using specified base branch: $base_branch"
fi

# --- Handle Forking and Pushing (Ensure remote is up-to-date *before* diff/commit checks) ---
base_remote_url=$(git remote get-url "$base_remote" 2>/dev/null) || {
  echo "Error: Could not get URL for base remote '$base_remote'." >&2
  exit 1
}

head_specifier="$head_branch" # Default head specifier for gh pr create

if [ "$base_remote" != "$head_remote" ]; then
  echo "Base and head remotes differ. Ensuring head remote '$head_remote' exists and is up-to-date."
  head_remote_url=$(git remote get-url "$head_remote" 2>/dev/null) # Check if head remote exists

  if [ -z "$head_remote_url" ]; then
    echo "Head remote '$head_remote' not found."
    read -rp "Do you want to fork '$base_remote_url' and add it as remote '$head_remote'? [y/N] " fork_confirm
    if [[ "$fork_confirm" =~ ^[Yy]$ ]]; then
      echo "Forking repository..."
      gh repo fork "$base_remote_url" --clone=false --remote=true --remote-name "$head_remote" || {
        echo "Error: Failed to fork repository." >&2
        exit 1
      }
      echo "Fork created and added as remote '$head_remote'."
      head_remote_url=$(git remote get-url "$head_remote") # Get URL after adding
    else
      echo "Aborting. Head remote '$head_remote' is required." >&2
      exit 1
    fi
  fi

  echo "Pushing branch '$head_branch' to head remote '$head_remote'..."
  git push --set-upstream "$head_remote" "$head_branch" || {
    echo "Error: Failed to push branch '$head_branch' to remote '$head_remote'." >&2
    exit 1
  }

  # Format head specifier for fork: owner:branch
  # Handle https://user:token@github.com/owner/repo format
  head_owner=$(echo "$head_remote_url" | sed -E 's#^https://([^@]+@)?github.com/([^/]+)/.*#\2#; s#^git@github.com:([^/]+)/.*#\1#')
  if [[ "$head_owner" != "$head_remote_url" ]] && [ -n "$head_owner" ]; then # Check if sed worked and owner is not empty
    head_specifier="$head_owner:$head_branch"
    echo "Using head specifier for fork: $head_specifier"
  else
    echo "Warning: Could not determine owner for head remote '$head_remote' from URL: $head_remote_url" >&2
    echo "Using default head specifier: $head_specifier"
    # head_specifier remains just "$head_branch"
  fi

else
  # Remotes are the same, ensure the branch is pushed
  echo "Pushing branch '$head_branch' to remote '$head_remote'..."
  # Check if the remote branch already exists and has an upstream set
  upstream_branch=$(git rev-parse --abbrev-ref "$head_branch@{upstream}" 2>/dev/null)
  remote_branch_exists=$(git ls-remote --heads "$head_remote" "$head_branch" | wc -l)

  if [ -n "$upstream_branch" ] || [ "$remote_branch_exists" -gt 0 ]; then
    # Upstream exists or remote branch exists, just push
    git push "$head_remote" "$head_branch" || {
      echo "Error: Failed to push branch '$head_branch' to remote '$head_remote'." >&2
      exit 1
    }
  else
    # No upstream and remote branch doesn't exist, push with --set-upstream
    git push --set-upstream "$head_remote" "$head_branch" || {
      echo "Error: Failed to push branch '$head_branch' to remote '$head_remote'." >&2
      exit 1
    }
  fi
  # head_specifier remains just "$head_branch"
fi

# --- Verify remote head branch exists after push ---
echo "Verifying remote head branch '$head_branch' exists on '$head_remote'..."
# Use --exit-code to get non-zero status if branch not found
# Redirect stdout to /dev/null as we only care about the exit code
if ! git ls-remote --exit-code --heads "$head_remote" "$head_branch" >/dev/null; then
  echo "Error: Head branch '$head_branch' not found on remote '$head_remote' after push." >&2
  echo "This could be a synchronization delay or a push failure." >&2
  echo "Please check the remote repository manually." >&2
  exit 1
fi
echo "Remote head branch verified."

# --- Generate diff (handle potential errors) ---
# Now that the remote is updated, check for diffs between the base *remote* branch and local HEAD
echo "Generating diff between $base_ref and HEAD..."
diff=$(git diff "$base_ref...HEAD")
if [ -z "$diff" ]; then
  echo "No differences found between $base_ref and HEAD. Have you pushed your latest changes?"
  exit 0
fi

# --- Get commit messages ---
echo "Getting commit messages between $base_ref and HEAD..."
commits=$(git log "$base_ref..HEAD" --pretty=format:"%s") # Get commit subjects
if [ -z "$commits" ]; then
  # Diff exists but no distinct commit messages (e.g., after amend/squash of initial commit)
  echo "Warning: No distinct commit messages found between $base_ref and HEAD, but a diff exists." >&2
  # Proceed without commit context for the AI prompt
fi

# --- Find and read PR template (Case-Insensitive) ---
template_content=""
template_path=""

# Look in standard locations using find -iname for case-insensitivity
# Prioritize .github/, then docs/, then root directory
# -maxdepth 1 prevents searching subdirectories within these locations
# -print -quit prints the first match and exits find immediately

# Check in .github/
if [ -d ".github" ]; then # Only search if the directory exists
  template_path=$(find .github -maxdepth 1 -type f -iname 'pull_request_template.md' -print -quit)
fi

# If not found, check in docs/
if [ -z "$template_path" ] && [ -d "docs" ]; then # Only search if not found yet and dir exists
  template_path=$(find docs -maxdepth 1 -type f -iname 'pull_request_template.md' -print -quit)
fi

# If still not found, check in the root directory
if [ -z "$template_path" ]; then
  # Search current directory (.) only, not subdirectories
  template_path=$(find . -maxdepth 1 -type f -iname 'pull_request_template.md' -print -quit)
fi

# --- Proceed if template was found ---
if [ -n "$template_path" ]; then
  echo "Found PR template: $template_path"
  # Read the template content, handle potential errors
  template_content=$(cat "$template_path")
  if [ $? -ne 0 ]; then
    echo "Warning: Could not read PR template file at $template_path"
    template_content="" # Reset if read failed
    template_path=""    # Also reset path if read failed
  fi
else
  echo "No PR template found."
fi

echo "Generating PR title and body..."

# --- Combine context ---
# Start building the context, including the template if found
context=""
# Use the template_content variable which is populated only if found and readable
if [ -n "$template_content" ]; then
  # Add a clear separator for the AI
  context="PR Template:\n---\n$template_content\n---\n\n"
fi
# Append commit messages and diff
context+="Commit Messages:\n$commits\n\nDiff:\n$diff"

# --- Define the AI prompt ---
# Instruct the AI to use all provided context, including the template
ai_prompt='Based on the following context (which may include a PR template, commit messages, and diff), your task is to respond with a PR title and body. The first line will be used as the PR title. All subsequent lines will be used as the PR body. If a template was provided, use its structure and sections as a guide for the body, filling it in based on the commits and diff.'

# --- Get title and body from AI (add basic error check) ---
# Assuming 'aichat' exists and works as described
# Send the combined context and the updated prompt to the AI
title_body=$(echo -e "$context" | aichat --role %functions% "$ai_prompt")

if [ -z "$title_body" ] || [ "$(echo "$title_body" | wc -l)" -lt 2 ]; then
  echo "Error: Failed to generate title and body from aichat."
  # Optionally fall back to manual input or exit
  read -rp "Enter PR Title: " title
  read -rp "Enter PR Body (Press Enter then Ctrl+D to finish): " body </dev/tty # Read multiline body from terminal
  if [ -z "$title" ]; then
    echo "Title cannot be empty. Exiting."
    exit 1
  fi
else
  title=$(echo "$title_body" | head -n 1)
  body=$(echo "$title_body" | tail -n +2) # Use tail -n +2 to get all lines from the second onwards for the body
fi

# --- Confirmation Prompt ---
# Using printf for potentially better formatting control, especially with multi-line body
prompt_text=$(printf "Create PR with:\n  Title: '%s'\n  Body:\n'''\n%s\n'''\n\nConfirm? [y/N] " "$title" "$body")

read -rp "$prompt_text" confirm

# --- Process Confirmation ---
# Corrected logic: proceed only if 'y' or 'Y' is entered. Default is No.
if [[ "$confirm" =~ ^[Yy]$ ]]; then
  echo "Proceeding with PR creation..."

  # Extract owner/repo from base remote URL for the --repo flag
  # Handles https://, https://user:token@, and git@ formats
  echo "DEBUG: Base remote URL for repo extraction: $base_remote_url" # Added Debugging
  repo_owner_name=$(echo "$base_remote_url" | sed -E 's#^https://([^@]+@)?github.com/([^/]+)/([^/]+)(\.git)?$#\2/\3#; s#^git@github.com:([^/]+)/([^/]+)(\.git)?$#\1/\2#')

  # Check if sed command failed to extract (result is the same as input OR result is empty)
  if [[ "$repo_owner_name" == "$base_remote_url" ]] || [[ -z "$repo_owner_name" ]]; then
    echo "Warning: Could not automatically determine repository owner/name from URL: $base_remote_url" >&2
    echo "Attempting 'gh pr create' without --repo flag." >&2
    # Use head_specifier determined earlier
    echo "Executing: gh pr create --base \"$base_branch\" --head \"$head_specifier\" --title \"$title\" --body <body omitted>"
    gh pr create --base "$base_branch" --head "$head_specifier" --title "$title" --body "$body"
  else
    echo "Targeting repository: $repo_owner_name"
    # Pass title, body, base branch, formatted head branch specifier, and target repo to gh pr create
    echo "Executing: gh pr create --repo \"$repo_owner_name\" --base \"$base_branch\" --head \"$head_specifier\" --title \"$title\" --body <body omitted>"
    gh pr create --repo "$repo_owner_name" --base "$base_branch" --head "$head_specifier" --title "$title" --body "$body"
  fi

  if [ $? -eq 0 ]; then
    echo "PR created successfully."
  else
    echo "Error: 'gh pr create' command failed." >&2
    exit 1 # Exit with error status if gh command fails
  fi
else
  echo "PR creation cancelled."
  exit 1 # Exit with a non-zero status to indicate cancellation
fi
