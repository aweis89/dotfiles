#!/usr/bin/env bash
CONFIG_FILE_NAME="tmux-sessionizer.conf"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/tmux-sessionizer"
CONFIG_FILE="$CONFIG_DIR/$CONFIG_FILE_NAME"
PANE_CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/tmux-sessionizer"
PANE_CACHE_FILE="$PANE_CACHE_DIR/panes.cache"

# config file example
# ------------------------
# # file: ~/.config/tmux-sessionizer/tmux-sessionizer.conf
# # If set this override the default TS_SEARCH_PATHS (~/ ~/personal ~/personal/dev/env/.config)
# TS_SEARCH_PATHS=(~/)
# # If set this add additional search paths to the default TS_SEARCH_PATHS
# # The number prefix is the depth for the Path [OPTIONAL]
# TS_EXTRA_SEARCH_PATHS=(~/ghq:3 ~/Git:3 ~/.config:2)
# # if set this override the TS_MAX_DEPTH (1)
# TS_MAX_DEPTH=2
# This is not meant to override .tmux-sessionizer.  At first i thought this
# would be a good command, but i don't think its ackshually what i want.
#
# Instead, its a list of commands to run on windows who's index is way outside
# of the first 10 windows.  This allows you to create as many windows in your
# session as you would like without having your workflow interrupted by these
# programatic windows
#
# how to use:
# tmux-sessionizer -w 0 will execute the first command in window -t 69.
# TS_SESSION_COMMANDS=(<cmd1> <cmd2>)
#
# TS_LOG=true # will write logs to ~/.local/share/tmux-sessionizer/tmux-sessionizer.logs
# TS_LOG_FILE=<file> # will write logs to <file> Defaults to ~/.local/share/tmux-sessionizer/tmux-sessionizer.logs
# ------------------------

if [[ -f "$CONFIG_FILE" ]]; then
	source "$CONFIG_FILE"
fi

if [[ -f "$CONFIG_FILE_NAME" ]]; then
	source "$CONFIG_FILE_NAME"
fi

if [[ $TS_LOG != "true" ]]; then
	if [[ -z $TS_LOG_FILE ]]; then
		TS_LOG_FILE="$HOME/.local/share/tmux-sessionizer/tmux-sessionizer.logs"
	fi

	mkdir -p "$(dirname "$TS_LOG_FILE")"
fi

log() {
	if [[ -z $TS_LOG ]]; then
		return
	elif [[ $TS_LOG == "echo" ]]; then
		echo "$*"
	elif [[ $TS_LOG == "file" ]]; then
		echo "$*" >>"$TS_LOG_FILE"
	fi
}

session_idx=""
session_cmd=""
user_selected=""
split_type=""
list_only=false
ai_mode=false
VERSION="0.1.0"

while [[ "$#" -gt 0 ]]; do
	case "$1" in
	-h | --help)
		echo "Usage: tmux-sessionizer [OPTIONS] [SEARCH_PATH]"
		echo "Options:"
		echo "  -h, --help             Display this help message"
		echo "  -s, --session <name>   session command index."
		echo "  --vsplit               Create vertical split (horizontal layout) for session command"
		echo "  --hsplit               Create horizontal split (vertical layout) for session command"
		exit 0
		;;
	-s | --session)
		session_idx="$2"
		if [[ -z $session_idx ]]; then
			echo "Session index cannot be empty"
			exit 1
		fi

		if [[ -z $TS_SESSION_COMMANDS ]]; then
			echo "TS_SESSION_COMMANDS is not set.  Must have a command set to run when switching to a session"
			exit 1
		fi

		if [[ -z "$session_idx" || "$session_idx" -lt 0 || "$session_idx" -ge "${#TS_SESSION_COMMANDS[@]}" ]]; then
			echo "Error: Invalid index. Please provide an index between 0 and $((${#TS_SESSION_COMMANDS[@]} - 1))."
			exit 1
		fi

		session_cmd="${TS_SESSION_COMMANDS[$session_idx]}"

		shift
		;;
	--vsplit)
		split_type="vsplit"
		;;
	--hsplit)
		split_type="hsplit"
		;;
	-v | --version)
		echo "tmux-sessionizer version $VERSION"
		exit 0
		;;
	--list)
		# Used internally for fzf reload
		list_only=true
		;;
	--ai)
		# Used internally to trigger AI agent on session start
		ai_mode=true
		;;
	*)
		user_selected="$1"
		;;
	esac
	shift
done

log "tmux-sessionizer($VERSION): idx=$session_idx cmd=$session_cmd user_selected=$user_selected split_type=$split_type log=$TS_LOG log_file=$TS_LOG_FILE"

# Validate split options are only used with session commands
if [[ -n "$split_type" && -z "$session_idx" ]]; then
	echo "Error: --vsplit and --hsplit can only be used with -s/--session option"
	exit 1
fi

sanity_check() {
	if ! command -v tmux &>/dev/null; then
		echo "tmux is not installed. Please install it first."
		exit 1
	fi

	if ! command -v fzf &>/dev/null; then
		echo "fzf is not installed. Please install it first."
		exit 1
	fi
}

switch_to() {
	if [[ -z $TMUX ]]; then
		log "attaching to session $1"
		tmux attach-session -t "$1"
	else
		log "switching to session $1"
		tmux switch-client -t "$1"
	fi
}

has_session() {
	tmux list-sessions | grep -q "^$1:"
}

get_session_command() {
	local dir="$1"
	if [[ ! -z $session_cmd ]]; then
		echo "$session_cmd"
	elif [ -f "$dir/.tmux-sessionizer" ]; then
		echo "source $dir/.tmux-sessionizer"
	elif [ -f "$HOME/.tmux-sessionizer" ]; then
		echo "source $HOME/.tmux-sessionizer"
	else
		echo "nvim"
	fi
}

hydrate() {
	if [[ ! -z $session_cmd ]]; then
		log "skipping hydrate for $1 -- using \"$session_cmd\" instead"
		return
	elif [ -f "$2/.tmux-sessionizer" ]; then
		log "sourcing(local) $2/.tmux-sessionizer"
		tmux send-keys -t "$1" "source $2/.tmux-sessionizer" c-M
	elif [ -f "$HOME/.tmux-sessionizer" ]; then
		log "sourcing(global) $HOME/.tmux-sessionizer"
		tmux send-keys -t "$1" "source $HOME/.tmux-sessionizer" c-M
	fi
}

is_tmux_running() {
	tmux_running=$(pgrep tmux)

	if [[ -z $TMUX ]] && [[ -z $tmux_running ]]; then
		return 1
	fi
	return 0
}

init_pane_cache() {
	mkdir -p "$PANE_CACHE_DIR"
	touch "$PANE_CACHE_FILE"
}

get_pane_id() {
	local session_idx="$1"
	local split_type="$2"
	init_pane_cache
	grep "^${session_idx}:${split_type}:" "$PANE_CACHE_FILE" | cut -d: -f3
}

set_pane_id() {
	local session_idx="$1"
	local split_type="$2"
	local pane_id="$3"
	init_pane_cache

	# Remove existing entry if it exists
	grep -v "^${session_idx}:${split_type}:" "$PANE_CACHE_FILE" >"${PANE_CACHE_FILE}.tmp" 2>/dev/null || true
	mv "${PANE_CACHE_FILE}.tmp" "$PANE_CACHE_FILE"

	# Add new entry
	echo "${session_idx}:${split_type}:${pane_id}" >>"$PANE_CACHE_FILE"
}

cleanup_dead_panes() {
	init_pane_cache
	local temp_file="${PANE_CACHE_FILE}.tmp"

	while IFS=: read -r idx split pane_id; do
		if tmux list-panes -a -F "#{pane_id}" 2>/dev/null | grep -q "^${pane_id}$"; then
			echo "${idx}:${split}:${pane_id}" >>"$temp_file"
		fi
	done <"$PANE_CACHE_FILE"

	mv "$temp_file" "$PANE_CACHE_FILE" 2>/dev/null || touch "$PANE_CACHE_FILE"
}

# Helper function for fzf preview - ensures bash execution
fzf_preview() {
	if echo "$1" | grep -q "^\[TMUX"; then
		session_name=$(echo "$1" | sed "s/^\[TMUX[^]]*\] //" | sed "s/ (.*)$//")
		session_path=$(tmux display-message -p -t "$session_name" "#{pane_current_path}" 2>/dev/null | sed "s|^$HOME|~|")
		echo "$session_path"
		tmux capture-pane -ep -S - -t "$session_name" 2>/dev/null || echo "Session not available"
	else
		dir_path="${1/#\~/$HOME}"
		if command -v eza >/dev/null 2>&1; then
			eza --color=always --tree --icons always "$dir_path" 2>/dev/null || echo "Directory not accessible"
		else
			ls -l --color=always "$dir_path" 2>/dev/null || echo "Directory not accessible"
		fi
	fi
}

# Helper function for fzf ctrl-x delete action
fzf_delete() {
	current_session=$(tmux display-message -p '#S' 2>/dev/null)
	deleted_current=false

	for line in "$@"; do
		if echo "$line" | grep -q '^\[TMUX'; then
			session_name=$(echo "$line" | sed 's/^\[TMUX[^]]*\] //' | sed 's/ (.*)$//')
			if [ "$session_name" = "$current_session" ]; then
				deleted_current=true
			fi
		fi
	done

	if [ "$deleted_current" = true ]; then
		if tmux has-session -t default 2>/dev/null; then
			tmux switch-client -t default
		fi
	fi

	for line in "$@"; do
		if echo "$line" | grep -q '^\[TMUX'; then
			session_name=$(echo "$line" | sed 's/^\[TMUX[^]]*\] //' | sed 's/ (.*)$//')
			if [ "$session_name" = "default" ]; then
				echo "Cannot delete 'default' session" >&2
				continue
			fi
			tmux kill-session -t "$session_name"
		else
			dir_path="${line/#\~/$HOME}"
			if [ -d "$dir_path" ]; then
				rm -rf "$dir_path"
			fi
		fi
	done
}

# Export functions so they're available to subshells
export -f fzf_preview
export -f fzf_delete

sanity_check

# if TS_SEARCH_PATHS is not set use default
[[ -n "$TS_SEARCH_PATHS" ]] || TS_SEARCH_PATHS=(~/p ~/c ~/wd ~/.local/share/chezmoi:0)

# Add any extra search paths to the TS_SEARCH_PATHS array
# e.g : EXTRA_SEARCH_PATHS=("$HOME/extra1:4" "$HOME/extra2")
# note : Path can be suffixed with :number to limit or extend the depth of the search for the Path

if [[ ${#TS_EXTRA_SEARCH_PATHS[@]} -gt 0 ]]; then
	TS_SEARCH_PATHS+=("${TS_EXTRA_SEARCH_PATHS[@]}")
fi

# utility function to find directories
find_dirs() {
	{
		# list TMUX sessions with current directory in parentheses
		if [[ -n "${TMUX}" ]]; then
			current_session=$(tmux display-message -p '#S')
			tmux list-sessions -F "#{session_name}:#{pane_current_path}" 2>/dev/null | while IFS=: read -r session_name session_path; do
				# Get first word of session name
				first_word=$(echo "$session_name" | awk '{print $1}')
				# Replace $HOME with ~ in path
				display_path=$(echo "$session_path" | sed "s|^$HOME|~|")
				# Mark child sessions (those with spaces) differently
				if [[ "$session_name" == *" "* ]]; then
					echo "[TMUX:child] $session_name ($display_path)"
				else
					echo "[TMUX] $first_word ($display_path)"
				fi
			done
		else
			tmux list-sessions -F "#{session_name}:#{pane_current_path}" 2>/dev/null | while IFS=: read -r session_name session_path; do
				# Get first word of session name
				first_word=$(echo "$session_name" | awk '{print $1}')
				# Replace $HOME with ~ in path
				display_path=$(echo "$session_path" | sed "s|^$HOME|~|")
				# Mark child sessions (those with spaces) differently
				if [[ "$session_name" == *" "* ]]; then
					echo "[TMUX:child] $session_name ($display_path)"
				else
					echo "[TMUX] $first_word ($display_path)"
				fi
			done
		fi

		# note: TS_SEARCH_PATHS is an array of paths to search for directories
		# if the path ends with :number, it will search for directories with a max depth of number ;)
		# if there is no number, it will search for directories with a max depth defined by TS_MAX_DEPTH or 1 if not set
		# if depth is 0, it will only include the path itself without subdirectories
		for entry in "${TS_SEARCH_PATHS[@]}"; do
			# Check if entry as :number as suffix then adapt the maxdepth parameter
			if [[ "$entry" =~ ^([^:]+):([0-9]+)$ ]]; then
				path="${BASH_REMATCH[1]}"
				depth="${BASH_REMATCH[2]}"
			else
				path="$entry"
			fi

			if [[ "${depth:-${TS_MAX_DEPTH:-1}}" == "0" ]]; then
				# depth 0 means only include the directory itself, not subdirectories
				[[ -d "$path" ]] && echo "$path"
			else
				[[ -d "$path" ]] && find "$path" -mindepth 1 -maxdepth "${depth:-${TS_MAX_DEPTH:-1}}" -path '*/.git' -prune -o -type d -print
			fi
		done
	} | sed "s|$HOME|~|g"
}

# Handle --list flag for fzf reload
if [[ "$list_only" == true ]]; then
	find_dirs
	exit 0
fi

handle_session_cmd() {
	log "executing session command $session_cmd with index $session_idx split_type=$split_type"
	if ! is_tmux_running; then
		echo "Error: tmux is not running.  Please start tmux first before using session commands."
		exit 1
	fi

	current_session=$(tmux display-message -p '#S')

	if [[ -n "$split_type" ]]; then
		handle_split_session_cmd "$current_session"
	else
		handle_window_session_cmd "$current_session"
	fi
	exit 0
}

handle_window_session_cmd() {
	local current_session="$1"
	start_index=$((69 + $session_idx))
	target="$current_session:$start_index"

	log "target: $target command $session_cmd has-session=$(tmux has-session -t="$target" 2>/dev/null)"
	if tmux has-session -t="$target" 2>/dev/null; then
		switch_to "$target"
	else
		log "executing session command: tmux neww -dt $target $session_cmd"
		tmux neww -dt $target "$session_cmd"
		hydrate "$target" "$selected"
		tmux select-window -t $target
	fi
}

handle_split_session_cmd() {
	local current_session="$1"
	cleanup_dead_panes

	# Check if pane already exists
	local existing_pane_id=$(get_pane_id "$session_idx" "$split_type")

	if [[ -n "$existing_pane_id" ]] && tmux list-panes -a -F "#{pane_id}" 2>/dev/null | grep -q "^${existing_pane_id}$"; then
		log "switching to existing pane $existing_pane_id"
		tmux select-pane -t "$existing_pane_id"
		if [[ -z $TMUX ]]; then
			tmux attach-session -t "$current_session"
		else
			tmux switch-client -t "$current_session"
		fi
	else
		# Create new split
		local split_flag=""
		if [[ "$split_type" == "vsplit" ]]; then
			split_flag="-h" # horizontal layout (vertical split)
		else
			split_flag="-v" # vertical layout (horizontal split)
		fi

		log "creating new split: tmux split-window $split_flag -c $(pwd) $session_cmd"
		local new_pane_id=$(tmux split-window $split_flag -c "$(pwd)" -P -F "#{pane_id}" "$session_cmd")

		if [[ -n "$new_pane_id" ]]; then
			set_pane_id "$session_idx" "$split_type" "$new_pane_id"
			log "created pane $new_pane_id for session_idx=$session_idx split_type=$split_type"
		fi
	fi
}

if [[ ! -z $session_cmd ]]; then
	handle_session_cmd
elif [[ ! -z $user_selected ]]; then
	selected="$user_selected"
else
	selected=$(find_dirs | fzf \
		--tmux 99% \
		--multi \
		--preview 'bash -c "fzf_preview {}"' \
		--preview-window 'right:60%' \
		--bind "tab:toggle+down" \
		--bind "ctrl-d:half-page-down" \
		--bind "ctrl-u:half-page-up" \
		--bind "ctrl-f:preview-page-down" \
		--bind "ctrl-b:preview-page-up" \
		--bind "ctrl-t:become(tmux-sessionizer --ai {})" \
		--bind "ctrl-x:execute-silent(bash -c \"fzf_delete {+}\")+reload(tmux-sessionizer --list)" \
		--header $'ENTER=switch | TAB=select+next | CTRL-T=AI | CTRL-X=delete\nCTRL-D/U=scroll | CTRL-F/B=preview') || true
fi

if [[ -z $selected ]]; then
	exit 0
fi

# Child sessions cannot be attached to directly
if [[ "$selected" =~ ^\[TMUX:child\] ]]; then
	echo "Cannot attach to child session. Access through parent session." >&2
	exit 0
fi

if [[ "$selected" =~ ^\[TMUX\]\ (.+)\ \(.*\)$ ]]; then
	# Extract session name (first word after [TMUX], before the path in parentheses)
	selected="${BASH_REMATCH[1]}"
fi

# Expand ~ back to $HOME for actual path usage
selected="${selected/#\~/$HOME}"

selected_name=$(basename "$selected" | tr . _)

session_start_cmd=$(get_session_command "$selected")

# If --ai flag was passed, override nvim command to trigger AI agent
if [[ "$ai_mode" == true ]]; then
	if [[ "$session_start_cmd" == "nvim" ]]; then
		session_start_cmd='nvim "+call feedkeys(\"\<C-t>\")"'
	fi
fi

if ! is_tmux_running; then
	tmux new-session -ds "$selected_name" -c "$selected" "$session_start_cmd"
	hydrate "$selected_name" "$selected"
fi

if ! has_session "$selected_name"; then
	tmux new-session -ds "$selected_name" -c "$selected" "$session_start_cmd"
	hydrate "$selected_name" "$selected"
fi

switch_to "$selected_name"
