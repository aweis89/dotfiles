#!/bin/bash

set -eo pipefail

# --- Default values ---
default_base_remote="origin"
default_head_remote="origin"

# --- Argument Parsing ---
base_remote="$default_base_remote"
base_branch=""
head_remote="$default_head_remote"
additional_prompt=""
debug=0

# Read from stdin if available (non-blocking)
if [ -t 0 ]; then
	stdin_prompt=""
else
	stdin_prompt=$(cat)
fi
additional_prompt="$stdin_prompt"

# Check if branch name contains a Jira ticket pattern and add ticket info to context
current_branch=$(git rev-parse --abbrev-ref HEAD)
jira_ticket=$(echo "$current_branch" | grep -o -E '^[A-Z]+-[0-9]+' || echo "")

if [ -n "$jira_ticket" ]; then
	echo "Found Jira ticket ID in branch name: $jira_ticket"
	jira_info=$(jira issue view --plain "$jira_ticket" 2>/dev/null || echo "Could not fetch Jira ticket info")

	if [ -n "$additional_prompt" ]; then
		additional_prompt="$additional_prompt"$'\n\n'"Jira Ticket: $jira_ticket"$'\n'"$jira_info"
	else
		additional_prompt="Jira Ticket: $jira_ticket"$'\n'"$jira_info"
	fi
fi

while [ $# -gt 0 ]; do
	case "$1" in
	-br | --base-remote)
		if [ -z "$2" ] || [[ "$2" == --* ]]; then
			echo "Error: Missing value for $1" >&2
			exit 1
		fi
		base_remote="$2"
		shift 2
		;;
	-bb | --base-branch)
		if [ -z "$2" ] || [[ "$2" == --* ]]; then
			echo "Error: Missing value for $1" >&2
			exit 1
		fi
		base_branch="$2"
		shift 2
		;;
	-hr | --head-remote)
		if [ -z "$2" ] || [[ "$2" == --* ]]; then
			echo "Error: Missing value for $1" >&2
			exit 1
		fi
		head_remote="$2"
		shift 2
		;;
	-p | --prompt)
		if [ -z "$2" ] || [[ "$2" == --* ]]; then
			echo "Error: Missing value for $1" >&2
			exit 1
		fi
		if [ -n "$stdin_prompt" ]; then
			additional_prompt="$additional_prompt"$'\n'"$2"
		else
			additional_prompt="$2"
		fi
		shift 2
		;;
	-d | --debug)
		debug=1
		shift
		;;
	-h | --help)
		echo "Usage: $0 [-br <remote>] [-bb <branch>] [-hr <remote>] [-p <prompt>] [-d|--debug] [-h|--help]"
		echo "  -br, --base-remote <remote>  Remote containing the target branch (default: $default_base_remote)."
		echo "  -bb, --base-branch <branch>  Target branch name (default: auto-detect from base-remote)."
		echo "  -hr, --head-remote <remote>  Remote to push the source branch to (default: value of --base-remote, or '$default_head_remote' if --base-remote is not set)."
		echo "  -p, --prompt <prompt>        Additional context/instructions for the AI generating the title/body."
		echo "  -d, --debug                  Print the generated prompt and exit (no opencode run)."
		echo "  -h, --help                   Show this help message."
		exit 0
		;;
	--)
		shift
		break
		;;
	*)
		echo "Error: Unknown option: $1" >&2
		exit 1
		;;
	esac
done

echo "Base Remote: $base_remote"
echo "Head Remote: $head_remote"
if [ -n "$additional_prompt" ]; then
	echo "Additional Prompt: $additional_prompt"
fi

# --- Get current branch (head branch) ---
head_branch=$(git rev-parse --abbrev-ref HEAD)
if [ -z "$head_branch" ] || [ "$head_branch" = "HEAD" ]; then
	echo "Error: Could not determine the current branch name." >&2
	exit 1
fi
echo "Head Branch (Current): $head_branch"

# --- Check for uncommitted changes ---
if ! git diff --quiet --exit-code; then
	echo "Warning: You have uncommitted changes." >&2
fi
if ! git diff --cached --quiet --exit-code; then
	echo "Warning: You have staged changes." >&2
fi

# --- Fetch base remote ---
echo "Fetching base remote '$base_remote'..."
git fetch "$base_remote"

# --- Determine Base Branch and Ref ---
if [ -z "$base_branch" ]; then
	base_ref=$(git symbolic-ref "refs/remotes/$base_remote/HEAD")
	if [ -z "$base_ref" ]; then
		echo "Error: Could not automatically determine the default branch for remote '$base_remote'." >&2
		echo "Please specify the target branch using --base-branch." >&2
		exit 1
	fi
	base_branch=$(basename "$base_ref")
	echo "Auto-detected base branch: $base_branch"
else
	base_ref="refs/remotes/$base_remote/$base_branch"
	if ! git show-ref --verify --quiet "$base_ref"; then
		echo "Error: Branch '$base_branch' not found on remote '$base_remote'." >&2
		echo "Please ensure the branch exists and the remote is fetched." >&2
		exit 1
	fi
	echo "Using specified base branch: $base_branch"
fi

# --- Handle Forking and Pushing ---
base_remote_url=$(git remote get-url "$base_remote" 2>/dev/null) || {
	echo "Error: Could not get URL for base remote '$base_remote'." >&2
	exit 1
}

head_specifier="$head_branch"

if ! [[ "$base_remote" == "$head_remote" ]]; then
	echo "Base and head remotes differ. Ensuring head remote '$head_remote' exists and is up-to-date."
	head_remote_url=$(git remote get-url "$head_remote" 2>/dev/null)

	if [ -z "$head_remote_url" ]; then
		echo "Head remote '$head_remote' not found."
		read -rp "Do you want to fork '$base_remote_url' and add it as remote '$head_remote'? [y/N] " fork_confirm
		if [[ "$fork_confirm" =~ ^[Yy]$ ]]; then
			echo "Forking repository..."
			gh repo fork "$base_remote_url" --clone=false --remote=true --remote-name "$head_remote" || {
				echo "Error: Failed to fork repository." >&2
				exit 1
			}
			echo "Fork created and added as remote '$head_remote'."
			head_remote_url=$(git remote get-url "$head_remote")
		else
			echo "Aborting. Head remote '$head_remote' is required." >&2
			exit 1
		fi
	fi

	echo "Pushing branch '$head_branch' to head remote '$head_remote'..."
	git push --set-upstream "$head_remote" "$head_branch" || {
		echo "Error: Failed to push branch '$head_branch' to remote '$head_remote'." >&2
		exit 1
	}

	head_owner=$(echo "$head_remote_url" | sed -E 's#^https://([^@]+@)?github.com/([^/]+)/.*#\2#; s#^git@github.com:([^/]+)/.*#\1#')
	if [[ "$head_owner" != "$head_remote_url" ]] && [ -n "$head_owner" ]; then
		head_specifier="$head_owner:$head_branch"
		echo "Using head specifier for fork: $head_specifier"
	else
		echo "Warning: Could not determine owner for head remote '$head_remote' from URL: $head_remote_url" >&2
		echo "Using default head specifier: $head_specifier"
	fi

else
	git push "$head_remote" "$head_branch" || {
		echo "Error: Failed to push branch '$head_branch' to remote '$head_remote'." >&2
		exit 1
	}
fi

# --- Verify remote head branch exists after push ---
echo "Verifying remote head branch '$head_branch' exists on '$head_remote'..."
if ! git ls-remote --exit-code --heads "$head_remote" "$head_branch" >/dev/null; then
	echo "Error: Head branch '$head_branch' not found on remote '$head_remote' after push." >&2
	echo "This could be a synchronization delay or a push failure." >&2
	echo "Please check the remote repository manually." >&2
	exit 1
fi
echo "Remote head branch verified."

# --- Quick check for changes ---
echo "Checking for changes between $base_ref and HEAD..."
if ! git diff --quiet "$base_ref...HEAD"; then
	echo "Changes detected."
else
	echo "No differences found between $base_ref and HEAD. Have you pushed your latest changes?"
	exit 0
fi

# --- Extract repo owner/name for gh pr create ---
repo_owner_name=$(echo "$base_remote_url" | sed -E 's#^[^/]+//[^/]+/(.*)#\1#; s#^[^:]+:(.*)#\1#; s#\.git$##')

# --- Find PR template ---
# GitHub supports PR templates in these locations (in order of precedence):
# 1. .github/pull_request_template.md
# 2. .github/PULL_REQUEST_TEMPLATE/*.md (multiple templates)
# 3. docs/pull_request_template.md
# 4. docs/PULL_REQUEST_TEMPLATE/*.md (multiple templates)
# 5. pull_request_template.md (root)
# 6. PULL_REQUEST_TEMPLATE/*.md (root, multiple templates)

template_path=""
template_dir=""

# Check .github/pull_request_template.md
if [ -z "$template_path" ] && [ -f ".github/pull_request_template.md" ]; then
	template_path=".github/pull_request_template.md"
fi

# Check .github/PULL_REQUEST_TEMPLATE/ directory
if [ -z "$template_path" ] && [ -d ".github/PULL_REQUEST_TEMPLATE" ]; then
	template_dir=".github/PULL_REQUEST_TEMPLATE"
	# Look for a default template or just use the first one
	if [ -f "$template_dir/pull_request_template.md" ]; then
		template_path="$template_dir/pull_request_template.md"
	else
		template_path=$(find "$template_dir" -maxdepth 1 -type f -name '*.md' -print -quit)
	fi
fi

# Check docs/pull_request_template.md
if [ -z "$template_path" ] && [ -f "docs/pull_request_template.md" ]; then
	template_path="docs/pull_request_template.md"
fi

# Check docs/PULL_REQUEST_TEMPLATE/ directory
if [ -z "$template_path" ] && [ -d "docs/PULL_REQUEST_TEMPLATE" ]; then
	template_dir="docs/PULL_REQUEST_TEMPLATE"
	if [ -f "$template_dir/pull_request_template.md" ]; then
		template_path="$template_dir/pull_request_template.md"
	else
		template_path=$(find "$template_dir" -maxdepth 1 -type f -name '*.md' -print -quit)
	fi
fi

# Check root pull_request_template.md
if [ -z "$template_path" ] && [ -f "pull_request_template.md" ]; then
	template_path="pull_request_template.md"
fi

# Check root PULL_REQUEST_TEMPLATE/ directory
if [ -z "$template_path" ] && [ -d "PULL_REQUEST_TEMPLATE" ]; then
	template_dir="PULL_REQUEST_TEMPLATE"
	if [ -f "$template_dir/pull_request_template.md" ]; then
		template_path="$template_dir/pull_request_template.md"
	else
		template_path=$(find "$template_dir" -maxdepth 1 -type f -name '*.md' -print -quit)
	fi
fi

if [ -n "$template_path" ]; then
	echo "Found PR template: $template_path"
else
	echo "No PR template found."
fi

# --- Build opencode prompt ---
echo ""
echo "========================================"
echo "Invoking opencode to generate PR..."
echo "========================================"
echo ""

opencode_prompt="Create a GitHub Pull Request by following these steps:

1. Run this git command to see the changes:
   git diff -U500 $base_ref...HEAD

2. Run this git command to see commit messages:
   git log $base_ref..HEAD --pretty=format:'%s'
"

if [ -n "$template_path" ]; then
	opencode_prompt+="
3. Read the PR template file at: $template_path
   Use its structure and sections as a guide for the PR body.
"
fi

if [ -n "$additional_prompt" ]; then
	opencode_prompt+="
4. Additional context from the user:
---
$additional_prompt
---
"
fi

opencode_prompt+="
4b. If you need more context to produce an accurate PR title/body, you MAY:
   - Run additional read-only git commands (e.g.: git diff -U200 $base_ref...HEAD, git log --oneline $base_ref..HEAD, git show <commit>, git blame <file>)
   - Read any project files relevant to the changes (source, README, docs, config, build scripts)
   - List directories or files (e.g.: ls -1, find . -maxdepth 3 -type f)
   - Inspect build or config files for intent (Makefile, go.mod, package.json, Dockerfile, CI workflows)
DO NOT:
   - Modify files
   - Stage/commit changes
   - Push to remotes
   - Run destructive or write-producing commands
Only gather context needed for an accurate summary of WHY + WHAT changed.

5. Generate a PR title and body that describes these changes:
   - The PR title MUST follow Semantic PR title conventions:
     * Format: <type>(<scope>): <subject>
     * Types: feat, fix, docs, style, refactor, perf, test, chore, ci, build, revert
     * Example: feat(api): add user authentication endpoint
     * Example: fix(ui): resolve button alignment issue
     * Keep subject lowercase and under 72 characters
     * Use imperative mood (\"add\" not \"added\" or \"adds\")
   - The PR body should follow the template structure if one exists
   - Focus on WHY these changes were made, not just WHAT changed

IMPORTANT: Output the PR title and body in the following parsable format:
---PR-TITLE---
<title>
---PR-BODY---
<body>
---END---"

# --- Debug mode: print prompt and exit ---
if [ "$debug" -eq 1 ]; then
	echo ""
	echo "========================================"
	echo "DEBUG MODE: Printing opencode prompt"
	echo "========================================"
	echo ""
	echo "$opencode_prompt"
	echo ""
	echo "========================================"
	echo "Debug mode enabled - exiting without running opencode"
	echo "========================================"
	exit 0
fi

# --- Run opencode and capture output ---
opencode_output=$(opencode run "$opencode_prompt")
echo "$opencode_output"

# --- Parse the output ---
pr_title=$(echo "$opencode_output" | sed -n '/---PR-TITLE---/,/---PR-BODY---/p' | sed '1d;$d')
pr_body=$(echo "$opencode_output" | sed -n '/---PR-BODY---/,/---END---/p' | sed '1d;$d')

if [ -z "$pr_title" ] || [ -z "$pr_body" ]; then
	echo ""
	echo "Error: Could not parse PR title and body from opencode output." >&2
	exit 1
fi

echo ""
echo "========================================"
echo "PR Title:"
echo "$pr_title"
echo ""
echo "PR Body:"
echo "$pr_body"
echo "========================================"
echo ""

read -rp "Create PR with this title and body? [y/N] " confirm
if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
	echo "Aborting PR creation."
	exit 0
fi

# --- Create the PR ---
echo "Creating PR..."
if [[ -z "$repo_owner_name" ]] || [[ "$repo_owner_name" == *"/"* && "$repo_owner_name" == *":"* ]] || [[ "$repo_owner_name" == *"//"* ]]; then
	gh pr create --base "$base_branch" --head "$head_specifier" --title "$pr_title" --body "$pr_body"
else
	gh pr create --repo "$repo_owner_name" --base "$base_branch" --head "$head_specifier" --title "$pr_title" --body "$pr_body"
fi

echo ""
echo "========================================"
echo "Done!"
echo "========================================"
